# **Конфигурационное управление. Практическая работа №3**
## Постановка задачи
Разработать ассемблер и интерпретатор для учебной виртуальной машины (УВМ)
### Спецификация УВМ
<div align="center">
    <hr>
<i>Загрузка константы</i>
    
| A                   | B                   |
|---------------------|---------------------|
| Биты 0—3            | Биты 4—28           |
| 6                   | Константа           |
</hr>
</div>
Размер команды: 4 байт. Операнд: поле B. Результат: новый элемент на стеке. <br>
Тест (A=6, B=479): <br>
0xF6, 0x1D, 0x00, 0x00 <br>
<div align="center">
<i>Чтение значения из памяти</i>
<hr>
  
| A                   | B                   |
|---------------------|---------------------|
| Биты 0—3            | Биты 4—24           |
| 12                  | Адрес               |
</hr>
</div>
Размер команды: 4 байт. Операнд: значение в памяти по адресу, которым является поле B. Результат: новый элемент на стеке. <br>
Тест (A=12, B=662): <br>
0x6C, 0x29, 0x00, 0x00 <br>
<div align="center">
<i>Запись значения в памяти</i>
<hr>
    
| A                   | B                   |
|---------------------|---------------------|
| Биты 0—3            | Биты 4—28           |
| 13                  | Адрес               |
</hr>
</div>
Размер команды: 4 байт. Операнд: элемент, снятый с вершины стека. Результат: значение в памяти по адресу, которым является поле B. <br>
Тест (A=13, B=807): <br>
0x7D, 0x32, 0x00, 0x00 <br>
<div align="center">
<i>Бинарная операция: побитовое "и"</i>
<hr>
    
| A                   | B                   |
|---------------------|---------------------|
| Биты 0—3            | Биты 4—24           |
| 2                   | Адрес               |

</div>
Размер команды: 4 байт. Первый операнд: элемент, снятый с вершины стека. Второй операнд: элемент, снятый с вершины стека. Результат: значение в памяти по адресу, которым является поле B. <br>
Тест (A=2, B=564): <br>
0x42, 0x23, 0x00, 0x00 <br>
</hr>
<hr> </hr>
В ходе работы были выполнены два этапа 

# Этап 1. Перевод программы в промежуточное представление

Цель: создать CLI-приложение ассемблера. Реализовать разбор текстового представления команд и трансляцию в промежуточное представление.

Требования:

1.Ассемблер должен принимать на вход аргументы командной строки:

–Путь к исходному файлу с текстом программы.

–Путь к двоичному файлу-результату.

–Режим тестирования.

2.Спроектировать человекочитаемый язык ассемблера, используя формат JSON. Поддержать все команды спецификации УВМ.

3.Описать в документации (например, в README.md) спроектированный язык ассемблера.

4.Реализовать транслятор, который язык ассемблера преобразует во внутреннее представление (например, список кортежей, объектов или словарей).

5.(только для данного этапа) В режиме тестирования вывести на экран внутреннее представление ассемблированной программы в формате полей и значений, как в тесте из спецификации УВМ.

6.Создать программу для тестов, приведенных в спецификации УВМ. Продемонстрировать, что ассемблер генерирует идентичные последовательности полей и их значений.

7.Результат выполнения этапа сохранить в репозиторий стандартно оформленным коммитом.
<hr> </hr>

# Этап 2 Формирование машинного кода
Цель: реализовать логику преобразования команд в их двоичное представление.

Требования:

1.Реализовать транслятор из промежуточного в машинное представление.

2.Записать результат ассемблирования в двоичный выходной файл.

3.Вывести на экран размер двоичного файла в байтах.

4.В режиме тестирования вывести результат ассемблирования на экран в байтовом формате, как в тесте из спецификации УВМ.

5.Создать файл на языке ассемблера, результат трансляции которого соответствует всем тестовым байтовым последовательностям из спецификации УВМ.

6.Результат выполнения этапа сохранить в репозиторий стандартно оформленным коммитом.
<hr> </hr>

# Как скачать и запустить

-git clone https://github.com/ilya98931/kisscm3.git

-cd kisscm3

-python main.py
